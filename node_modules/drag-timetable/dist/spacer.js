'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TimetableSpacer = function () {
  function TimetableSpacer(hourStart, hourEnd, taskArea, table, unitHeight, orientation, callbacks) {
    (0, _classCallCheck3.default)(this, TimetableSpacer);

    this.hourStart = hourStart;
    this.hourEnd = hourEnd;
    this.taskArea = taskArea;
    this.table = table;
    this.unitHeight = unitHeight;
    this.orientation = orientation;
    this.callbacks = callbacks;
    this.spacerIdToElementArray = [];
    this.timeToSpacerMap = {};
    this.spacerToTimeMap = {};
    this._initSpacers();
  }

  (0, _createClass3.default)(TimetableSpacer, [{
    key: 'moveStart',
    value: function moveStart(selectedTaskId) {
      var selectedTask = this.callbacks.getTask(selectedTaskId);
      var boundary = this.timeToSpacerMap[selectedTask.start].boundary;
      this.currentAvailSlot = { spacerId: boundary[0], lastSpacerId: boundary[1] };
      this.removeFromTable(selectedTask);
    }
  }, {
    key: 'moveUpdate',
    value: function moveUpdate(mouseOffset, selectedTaskId) {
      var selectedTask = this.callbacks.getTask(selectedTaskId);
      var availSlotResult = this.getClosestAvailableSlot(mouseOffset, selectedTask);
      if (availSlotResult) {
        this.currentAvailSlot = availSlotResult;
      }
    }
  }, {
    key: 'moveEnd',
    value: function moveEnd(selectedTaskId) {
      var selectedTask = this.callbacks.getTask(selectedTaskId);
      if (!this.currentAvailSlot) {
        return;
      }
      this.addToTable(selectedTask, this.currentAvailSlot.spacerId, this.currentAvailSlot.lastSpacerId);
      this.callbacks.onTaskTimeUpdate(selectedTask.id, this.spacerToTimeMap[this.currentAvailSlot.spacerId], this.spacerToTimeMap[this.currentAvailSlot.lastSpacerId] + 0.25);
    }
  }, {
    key: 'getClosestAvailableSlot',
    value: function getClosestAvailableSlot(mouseOffset, selectedTask) {
      var spacerLength = Math.floor((selectedTask.end - selectedTask.start) * 4.0);
      for (var i = this.spacerIdToElementArray.length - 1; i >= 0; i--) {
        var spacerElement = this.spacerIdToElementArray[i];
        if (spacerElement.style.display === 'none') {
          continue;
        }
        var clientRect = spacerElement.getBoundingClientRect();
        var spacerPosition = this.orientation === 'horizontal' ? clientRect.left : clientRect.top;
        if (i == 0 || mouseOffset > spacerPosition) {
          var conflictDetected = false;
          var lastSpacerId = 0;
          for (var f = i; f < i + spacerLength; f += 1) {
            var currTime = this.spacerToTimeMap[f];
            if (this.timeToSpacerMap[currTime] === undefined || this.timeToSpacerMap[currTime] === null || this.timeToSpacerMap[currTime] && this.timeToSpacerMap[currTime].taskId && this.timeToSpacerMap[currTime].taskId !== selectedTask.id) {
              conflictDetected = true;
            }
            lastSpacerId = f;
          }
          if (!conflictDetected) {
            return { spacerId: i, lastSpacerId: lastSpacerId };
          }
        }
      }
      return false;
    }
  }, {
    key: 'addToTable',
    value: function addToTable(task, availSlotStart, availSlotEnd) {
      var taskStart = task.start;
      var taskEnd = task.end;
      if (availSlotStart !== undefined && availSlotStart !== null && availSlotEnd !== undefined && availSlotEnd !== null) {
        taskStart = this.spacerToTimeMap[availSlotStart];
        taskEnd = this.spacerToTimeMap[availSlotEnd + 1];
      }

      for (var i = 0.0 + taskStart; i < taskEnd; i += 0.25) {
        if (this.timeToSpacerMap[i] && this.timeToSpacerMap[i].taskId) {
          throw 'No available slots!';
        }
      }
      var startSpacerId = this.timeToSpacerMap[taskStart];
      var endSpacerId = this.timeToSpacerMap[taskEnd - 0.25];
      for (var _i = 0.0 + taskStart; _i < taskEnd; _i += 0.25) {
        var spacerId = this.timeToSpacerMap[_i];
        this.timeToSpacerMap[_i] = { taskId: task.id, boundary: [this.timeToSpacerMap[taskStart], this.timeToSpacerMap[taskEnd - 0.25]], availableValue: spacerId };
        if (_i == taskStart) {
          this.spacerIdToElementArray[spacerId].style.display = '';
          this.spacerIdToElementArray[spacerId].appendChild(task.element);
          this.spacerIdToElementArray[spacerId].setAttribute('rowspan', '' + (endSpacerId - startSpacerId + 1));
        } else {
          this.spacerIdToElementArray[spacerId].style.display = 'none';
        }
      }
    }
  }, {
    key: 'removeFromTable',
    value: function removeFromTable(task) {
      var startSpacerId = this.timeToSpacerMap[task.start];
      var endSpacerId = this.timeToSpacerMap[task.end - 0.25];
      for (var i = 0.0 + task.start; i < task.end; i += 0.25) {
        var spacerObj = this.timeToSpacerMap[i];
        if (!spacerObj.taskId) {
          continue;
        }
        this.timeToSpacerMap[i] = spacerObj.availableValue;
        var spacerId = spacerObj.availableValue;
        if (i == task.start) {
          this.spacerIdToElementArray[spacerId].removeChild(this.spacerIdToElementArray[spacerId].firstChild);
          this.spacerIdToElementArray[spacerId].setAttribute('rowspan', '1');
        } else {
          this.spacerIdToElementArray[spacerId].style.display = '';
        }
      }
    }
  }, {
    key: '_initSpacers',
    value: function _initSpacers() {
      var _this = this;

      var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

      for (var i = 0.0 + this.hourStart; i < this.hourEnd; i += 0.25) {
        var rowElement = document.createElement('tr');
        var spaceElement = document.createElement('td');
        rowElement.style.height = this.unitHeight;
        spaceElement.setAttribute('class', 'dragtimetable-spacer');
        if (isFirefox) {
          spaceElement.style.height = '100%';
        }
        this.spacerIdToElementArray.push(spaceElement);
        this.timeToSpacerMap[i] = this.spacerIdToElementArray.length - 1;
        this.spacerToTimeMap[this.spacerIdToElementArray.length - 1] = i;
        rowElement.appendChild(spaceElement);
        this.taskArea.appendChild(rowElement);
      }
      this.spacerToTimeMap[this.spacerIdToElementArray.length] = this.hourEnd;
      window.addEventListener('resize', function () {
        _this.taskArea.style.height = _this.table.clientHeight + "px";
      });
      this.taskArea.style.height = this.table.clientHeight + "px";
    }
  }]);
  return TimetableSpacer;
}();

exports.default = TimetableSpacer;